#!/bin/bash
#ファイル名: burm
#作成日: 2025
#作成内容: redmineのバックアップシェルスクリプト
#説明：Redmineのfiles、config、DBをバックアップするスクリプト
#　　　daily、weekly、monthlyのバックアップを取得する
#options:
#　　[-d : Dailyバックアップ|
#　　-w : Weeklyバックアップ|
#　　-m : Monthlyバックアップ|
#　　-r : バックアップファイルのローテーション|
#　　-h : ヘルプ]
#/usr/binに保存
#実行例：burm -d
##注意点：pg_dumpの実行には、PostgreSQLのユーザー名とパスワードが必要
#crontab -eに登録する場合は、以下のように記述例
#　　0 0 * * * /usr/bin/burm -d
#　　0 0 * * 0 /usr/bin/burm -w
#　　0 0 1 * * /usr/bin/burm -m


#注意点：filesディレクトリがコピーできないバグが発生しているので個別でmkdirしている

#　root権限で実行することを確認
[[ $EUID -eq 0 ]] || { echo "root で実行してください"; exit 1; }



# ###################################################################################
# 変数定義
# ###################################################################################
#バックアップ先親ディレクトリ
BACKUP_DIR=/var/backups/redmine
#バックアップ元(redmineのファイルズディレクトリ)
REDMINE_FILE_DIR=/var/lib/redmine/files
#バックアップ元(redmineのコンフィグディレクトリ)
REDMINE_CONFIG_DIR=/var/lib/redmine/config

#時間の文字列：yyyy-mm-dd_hh:mm:ss
#現在の時間を取得
DATE_DIR=$(date +%Y-%m-%d_%H-%M-%S)

#フォルダを定義：[daily|weekly|monthly]
DAILY_DIR=$BACKUP_DIR/daily
WEEKLY_DIR=$BACKUP_DIR/weekly
MONTHLY_DIR=$BACKUP_DIR/monthly

#データベースの設定
DB_NAME=redmine
DB_USER=redmine
DB_PASS=testpass
DB_HOST=localhost

#ローテーションの設定
#daily（日次）バックアップのローテーション(世代数)
DAILY_ROTATE=4
#weekly（週次）バックアップのローテーション（世代数）
WEEKLY_ROTATE=5
#monthly（月次）バックアップのローテーション（世代数）
MONTHLY_ROTATE=1

#バックアップファイルの取り扱いグループ
CH_BACKUP_OWNER_GROUP=root:user
#バックアップファイルのパーミッション
CH_BACKUP_PERMISSION="755"

#レストアファイルの取り扱いグループ
CH_RESTORE_OWNER_GROUP=root:root
#リストアファイルのパーミッション
CH_RESTORE_PERMISSION=777

RESTOR_DIR="/var/backups/redmine/restore_files"


# ###################################################################################
#　関数
# ###################################################################################
#フォルダ作成の関数
# $1: フォルダpath
#戻り値: フォルダ作成成功時は0、失敗時は1
make_dir() {
    mkdir -p $1
    if [ $? -ne 0 ]; then
        echo "フォルダの作成に失敗しました: $1"
        exit 1
    fi
    echo "フォルダを作成しました: $1" 
    return 0
}


#バックアップ元のコピー
#$1: コピー元ディレクトリ
#$2: コピー先ディレクトリ
#戻り値: コピー成功時は0、失敗時は1
copy_files() {
    # $1: コピー元ディレクトリ
    local SOURCE_DIR="$1"
    # $2: コピー先ディレクトリ
    local DEST_DIR="$2"
    #　コピー先にディレクトリをコピー
    #　--preserve=ownershipオプションを使用して、所有権を保持
    #　--recursiveオプションを使用して、ディレクトリを再帰的にコピー
    #　--preserve=modeオプションを使用して、パーミッションを保持
    cp -rp --preserve=ownership $SOURCE_DIR $DEST_DIR
    if [ $? -ne 0 ]; then
        echo "バックアップのコピーに失敗しました: $SOURCE_DIR"
        exit 1
    fi
    echo "バックアップをコピーしました: $SOURCE_DIR -> $DEST_DIR"
    chmod -R $CH_BACKUP_PERMISSION $DEST_DIR
    chown -R $CH_BACKUP_OWNER_GROUP $DEST_DIR
    return 0
}


#pg_dumpの実行関数
#$1: バックアップ先ディレクトリ
dump() {
    local FILE_NAME=db_dump.sqlc
    local BACKUP_DIR="$1"
    export PGPASSWORD=$DB_PASS
    trap 'unset PGPASSWORD' RETURN

    #pg_dump -U "$DB_USER" -h "$DB_HOST" "$DB_NAME" > "$BACKUP_DIR/$FILE_NAME"
    pg_dump -U "$DB_USER" -h "$DB_HOST" -Fc --file="$BACKUP_DIR/$FILE_NAME" "$DB_NAME"
    if [ $? -ne 0 ]; then
        echo "データベースのバックアップに失敗しました: $1" >&2
        return 1
    fi
    chmod -R $CH_BACKUP_PERMISSION $BACKUP_DIR/$FILE_NAME
    chown -R $CH_BACKUP_OWNER_GROUP $BACKUP_DIR/$FILE_NAME
    echo "pg_dumpを実行しました: $BACKUP_DIR"
    return 0
}
#メモ
# 圧縮形式で保存する場合
# リストア時、DBを初期化する場合
#pg_dump -U PostgreSQLユーザー名 -h ホスト名 -Fc --file=ダンプデータファイル名 Redmineデータベース名
#PGPASSWORD='$DB_PASS' pg_restore -h データベースサーバのIPアドレス -U データベースのユーザー名 -d データベース名 --clean --if-exists --no-owner xxxxxxxx.sqlc


#圧縮してtar.gzに置き換える関数
#$1: バックアップ先ディレクトリ
#$2: バックアップファイル名
commpress() {
    cd $1
    tar -czPf $2.tar.gz $2
    if [ $? -ne 0 ]; then
        echo "圧縮に失敗しました: $1/$2" >&2
        return 1
    fi
    echo "圧縮しました: $1/$2"

    # 圧縮したファイルの所有者とグループを変更
    chmod $CH_BACKUP_PERMISSION $2.tar.gz
    chown $CH_BACKUP_OWNER_GROUP $2.tar.gz

    #圧縮前のフォルダは削除
    rm -rf $1/$2
    return 0
}


#バックアップのメイン処理
#$1: バックアップ先ディレクトリ
#$2: バックアップファイル名
backup() {


    local TARGET_DIR=$1
    #make_dir "$TARGET_DIR"
    
    local DATE_DIR=$2
    make_dir "$TARGET_DIR/$DATE_DIR"
    

    #バックアップする度全て$CH_BACKUP_OWNER_GROUP、$CH_BACKUP_PERMISSIONになる
    chmod -R $CH_BACKUP_PERMISSION $BACKUP_DIR
    chown -R $CH_BACKUP_OWNER_GROUP $BACKUP_DIR


    # filesディレクトリのバックアップコピー
    copy_files "$REDMINE_FILE_DIR" "$TARGET_DIR/$DATE_DIR"
    

    # configのディレクトリのバックアップコピー
    copy_files "$REDMINE_CONFIG_DIR" "$TARGET_DIR/$DATE_DIR"


    dump "$TARGET_DIR/$DATE_DIR"
    commpress "$TARGET_DIR" "$DATE_DIR"
}




# ##################################################################################
#　ローテーション処理
# ##################################################################################

# ローテーション処理
rotate() {
    local TARGET_DIR=$1
    local ROTATE=$2
    local FILES=($(ls -t $TARGET_DIR/*.tar.gz))
    local COUNT=${#FILES[@]}

    if [ $COUNT -gt $ROTATE ]; then
        for ((i=$ROTATE; i<$COUNT; i++)); do
            rm -f "${FILES[$i]}"
            echo "ローテーション: ${FILES[$i]}を削除しました"
        done
    fi
}
# ########################################################################################
#　restore処理
# ########################################################################################

decomp() {
    #これは相対パス、絶対パスでも解凍できる関数
    # $1: tar.gzファイルのパス（相対・絶対どちらでもOK）
    local DECOMP_ABS_PATH=$(realpath $1)    # realpath: 絶対パスを取得
    if [ ! -f "$DECOMP_ABS_PATH" ]; then
        echo "tar.gzファイルが存在しません: $DECOMP_ABS_PATH" >&2
        exit 1
    fi
    echo "フルパスOK：$DECOMP_ABS_PATH"

    # $DECOMP_ABS_PATHからディレクトリ名とファイル名を取得
    local DIR_NAME=$(dirname "$DECOMP_ABS_PATH")    # dirname: ディレクトリ名を取得
    local FILE_NAME=$(basename "$DECOMP_ABS_PATH")  # basename: ファイル名を取得

    #.tar.gzファイルか確認
    # .tar.gzファイルでない場合は終了
    if [[ ! $DECOMP_ABS_PATH =~ \.tar\.gz$ ]]; then
        echo "tar.gzファイルではありません: $DECOMP_ABS_PATH" >&2
        echo "解凍処理を実行できません" >&2
        exit 1
    fi
    echo ".tar.gzファイルの有OK"
    echo "ファイル名：$FILE_NAME"

    # DIR_NAMEが存在するか確認
    # DIR_NAMEが存在しない場合は終了
    if [ ! -d "$DIR_NAME" ]; then
        echo "圧縮ファイルの親ディレクトリが存在しません: $DIR_NAME" >&2
        exit 1
    fi
    echo "親ディレクトリOK：$DIR_NAME"
    echo "ファイル確認の整合OK：$DECOMP_ABS_PATH"

    # $FILE_NAMEの圧縮ファイルから.tar.gzを削除
    local DECOMPED_DIR_NAME=${FILE_NAME%.tar.gz}

    mkdir -p $RESTOR_DIR
    #chmod $CH_BACKUP_PERMISSION $RESTOR_DIR
    #chown $CH_BACKUP_OWNER_GROUP $RESTOR_DIR
    cp -a $DECOMP_ABS_PATH $RESTOR_DIR/$FILE_NAME
    if [ $? -ne 0 ]; then
        echo "ファイルのコピーに失敗しました: $DIR_NAME/$FILE_NAME" >&2
        exit 1
    fi
    echo "ファイルコピー成功：$DIR_NAME/$FILE_NAME -> $RESTOR_DIR/$FILE_NAME"

    #　コピーしてきたファイルを解凍して解凍したフォルダだけ残す
    cd $RESTOR_DIR/
    tar -xzf $RESTOR_DIR/$FILE_NAME
    rm -f $RESTOR_DIR/$FILE_NAME
    
    #$DECOMPED_DIR_NAMEが存在するか確認
    # $DECOMPED_DIR_NAMEが存在しない場合は終了
    if [ ! -d "$DECOMPED_DIR_NAME" ]; then
        echo "解凍先ディレクトリが存在しません: $DIR_NAME/$DECOMPED_DIR_NAME" >&2
        exit 1
    fi
    echo "解凍先ディレクトリOK：$DIR_NAME/$FILE_NAME -> $RESTOR_DIR/$DECOMPED_DIR_NAME"
    cd /
    echo "=================解凍完了====================="
    return 0
}



#　SQLのリストア
db_format(){
    local RESTORE_DB_FULL_PATH="$RESTOR_DIR/$DECOMPED_DIR_NAME/$SQL_COMPED_FILE_NAME"
    if [ ! -f "$RESTORE_DB_FULL_PATH" ]; then
        echo "リストア用DBファイルが存在しません: $RESTORE_DB_FULL_PATH" >&2
        exit 1
    fi
    echo "リストア用SQLファイルパス：$RESTORE_DB_FULL_PATH"
    local DBUSER_MAKE="CREATE USER $DB_USER WITH PASSWORD '$DB_PASS';"
    
    #パスワードを出力
    export PGPASSWORD=$DB_PASS
    trap 'unset PGPASSWORD' RETURN


    # データベースに接続しているセッションを終了############################################################
    echo ""
    echo ""
    echo ""
    echo ""
    sudo -u postgres psql -c "SELECT pg_terminate_backend(pid) FROM pg_stat_activity WHERE datname = '${DB_NAME}' AND pid <> pg_backend_pid();"
    echo ""
    echo ""
    echo ""
    echo ""


    #　注意喚起###################################################################################
    echo "以下の実行はy or n でお答えください。"
    echo "yで答えたならば処理完了が出るまでお待ちください。"
    echo "処理に失敗した場合はお手数ですが手動でリストアをお願いします。"
    echo
    echo


    #　データベース削除###################################################################################
    #echo "sudo -u postgres psql -c DROP DATABASE IF EXISTS ${DB_NAME};"
    read -p "データベース削除実行(y/n): " DBconfirm
    if [[ $DBconfirm == "y" || $DBconfirm == "Y" ]]; then
        echo "〇〇〇〇〇〇〇〇〇〇〇〇〇〇〇〇〇〇〇〇〇〇〇〇"
        echo "データベース削除中"
    else
        echo "処理を中止します。"
        exit 0
    fi
    sudo -u postgres psql -c "DROP DATABASE IF EXISTS ${DB_NAME};"
    if [ $? -ne 0 ]; then
        echo "処理に失敗しました。"
    fi
    echo
    echo "データベース削除をの処理完了"
    echo
    echo
    echo


    #　初期の作成テンプレート使用##########################################################################
    #echo "sudo -u postgres createdb -E UTF-8 -l ja_JP.UTF-8 -O redmine -T template0 redmine"
    read -p "データベース作成を実行(y/n): " USRconfirm
    if [[ $USRconfirm == "y" || $USRconfirm == "Y" ]]; then
        echo "〇〇〇〇〇〇〇〇〇〇〇〇〇〇〇〇〇〇〇〇〇〇〇〇"
        echo "データベース作成中"
    else
        echo "処理を中止します。"
    fi


    sudo -u postgres createdb -E UTF-8 -l ja_JP.UTF-8 -O redmine -T template0 redmine
    if [ $? -ne 0 ]; then
        echo "処理に失敗しました。"
    fi
    echo
    echo "データベースの作成完了"
    echo
    echo
    echo


    #　restoreコマンド：データベース復旧##########################################################################
    #echo "sudo pg_restore -h $DB_HOST -U $DB_USER -d $DB_NAME --clean --if-exists --no-owner $RESTORE_DB_FULL_PATH"
    read -p "データベースのリストア実行(y/n): " DBRconfirm
    if [[ $DBRconfirm == "y" || $DBRconfirm == "Y" ]]; then
        echo "〇〇〇〇〇〇〇〇〇〇〇〇〇〇〇〇〇〇〇〇〇〇〇〇"
        echo "リストア実行中"
    else
        echo "処理を中止します。"
    fi
    #パスワード出力
    export PGPASSWORD=$DB_PASS
    trap 'unset PGPASSWORD' RETURN
    sudo -E pg_restore -h $DB_HOST -U $DB_USER -d $DB_NAME --clean --if-exists --no-owner $RESTORE_DB_FULL_PATH
    if [ $? -ne 0 ]; then
        echo "リストア処理に失敗しました。"
    fi
    echo
    echo "リストア完了"
    echo
    echo
    echo
    
    return 0
}


restore(){
    local TARGET_DIR=$DECOMPED_DIR_FULL_PATH

    #RESTOR_DIRのフォルダへ .tar.gzのファイルコピー
    #解凍
    #解凍前targzファイルを削除
    decomp $1
    if [ $? -ne 0 ]; then
        echo "ファイルの解凍に失敗しました: " >&2
        exit 1
    fi
    echo "===============================================解凍完了==============================================="

    #$1:リストアディレクトリ
    #$2:インプットディレクトリ
    #$3:固定の存在フォルダ
    rm -rf $REDMINE_FILES_DIR
    cp -ar $DECOMPED_DIR_FULL_PATH/files $REDMINE_DIR/
    if [ $? -ne 0 ]; then
        echo "ファイルのコピーに失敗しました: " >&2
        exit 1
    fi
    echo "ファイルコピー成功：$DECOMPED_DIR_FULL_PATH/files $REDMINE_DIR/files"


    rm -rf $REDMINE_CONFIG_DIR
    cp -ar $DECOMPED_DIR_FULL_PATH/config $REDMINE_DIR/
    if [ $? -ne 0 ]; then
        echo "ファイルのコピーに失敗しました: " >&2
        exit 1
    fi
    echo "ファイルコピー成功：$DECOMPED_DIR_FULL_PATH/config $REDMINE_DIR/config"
    echo "===============================================ファイルの復元完了==============================================="


    #DB・ユーザの削除
    #ユーザー作成・DBのみ作成
    #RESTOR_DIR内のSQL_COMPED_FILE_NAMEを読み取ってDBをリストア
    db_format
    if [ $? -ne 0 ]; then
        echo "PostgresSQLの復元に失敗しました。: " >&2
        exit 1
    fi


    echo "===============================================PostgresSQLの復元完了==============================================="

}


# ###################################################################################
#　メイン処理
# ###################################################################################
#引数の解析
while getopts "dwmrhcu" opt; do
    case $opt in
        d) # Dailyバックアップ
            echo "Dailyバックアップを開始します"
            echo "===============================================dailyバックアップ==============================================="
            backup "$DAILY_DIR" "$DATE_DIR"
            rotate "$DAILY_DIR" "$DAILY_ROTATE"
            ;;
        w) # Weeklyバックアップ
            echo "Weeklyバックアップを開始します"
            echo "===============================================dailyバックアップ==============================================="
            backup "$WEEKLY_DIR" "$DATE_DIR"
            rotate "$WEEKLY_DIR" "$WEEKLY_ROTATE"
            ;;
        m) # Monthlyバックアップ
            echo "===============================================dailyバックアップ==============================================="
            echo "Monthlyバックアップを開始します"
            backup "$MONTHLY_DIR" "$DATE_DIR"
            rotate "$MONTHLY_DIR" "$MONTHLY_ROTATE"
            ;;
        r) # バックアップファイルのローテーション
            echo "===============================================ローテーション==============================================="
            echo "バックアップファイルのローテーションを開始します"
            rotate "$DAILY_DIR" "$DAILY_ROTATE"
            rotate "$WEEKLY_DIR" "$WEEKLY_ROTATE"
            rotate "$MONTHLY_DIR" "$MONTHLY_ROTATE"
            ;;
        h) # ヘルプ
            echo "オプション: [-d:daily backup]"
            echo "　　　　　　[-w:weekly backup]"
            echo "　　　　　　[-m:monthly backup]"
            echo "　　　　　　[-r:rotetion]"
            echo "　　　　　　[-h:help]"
            exit 0
            ;;
        c) # backupの全削除
            read -p "本当に削除しますか？(y/n): " confirm
            if [[ $confirm == "y" || $confirm == "Y" ]]; then
                rm -rf $BACKUP_DIR
                echo "===============================================バックアップディレクトリを削除しました==============================================="
            else
                echo "バックアップの削除をキャンセルしました"
            fi
            exit 1
            ;;
        u) # backupのリストア
            echo ”===============================================バックアップのリストア===============================================”
            read -p "リストアを実行しますか？(y/n): " confirm
            if [[ $confirm == "y" || $confirm == "Y" ]]; then
                echo "リストアを実行します"
                #test
                decomp $2
            else
                echo "リストアをキャンセルしました"
                exit 1
            fi

            exit 1
            ;;

        \?) # 無効なオプション
            echo "無効なオプションです: -$OPTARG" >&2
            echo "-h: ヘルプを参照してください。"
            exit 1
            ;;
    esac
done
#pg_restore -h $DB_HOST -U $DB_USER -d $DB_NAME --clean --if-exists --no-owner xxxxxxxx.sqlc

